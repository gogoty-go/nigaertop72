<!DOCTYPE html>
<html>
<head>
    <title>SYSTEM STRESS TEST</title>
    <meta charset="UTF-8">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body, html {
            width: 100%;
            height: 100%;
            background: #000;
            font-family: 'Arial', sans-serif;
            touch-action: none;
        }
        
        #glCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
        }
        
        #statsPanel {
            position: fixed;
            top: 20px;
            left: 20px;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            text-shadow: 0 0 5px #0f0;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid #0f0;
        }
        
        #warning {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 72px;
            text-align: center;
            text-transform: uppercase;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 0 0 30px #f00;
            font-weight: bold;
            pointer-events: none;
        }
        
        #startButton {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(to right, #ff0066, #6600ff);
            color: white;
            border: none;
            padding: 25px 60px;
            font-size: 32px;
            font-weight: bold;
            border-radius: 50px;
            cursor: pointer;
            z-index: 300;
            text-transform: uppercase;
            letter-spacing: 3px;
            box-shadow: 0 0 50px rgba(255, 0, 102, 0.7);
            transition: all 0.4s;
        }
        
        #startButton:hover {
            transform: translate(-50%, -50%) scale(1.1);
            box-shadow: 0 0 70px rgba(255, 0, 102, 0.9);
        }
        
        #startButton:active {
            transform: translate(-50%, -50%) scale(0.95);
        }
        
        .memory-block {
            position: absolute;
            background: rgba(255, 0, 255, 0.1);
            border: 1px solid rgba(0, 255, 255, 0.3);
            pointer-events: none;
            z-index: 10;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <div id="statsPanel">
        <div>CPU: <span id="cpuLoad">0%</span></div>
        <div>GPU: <span id="gpuLoad">0%</span></div>
        <div>RAM: <span id="ramUsage">0 MB</span></div>
        <div>TEMP: <span id="temp">0°C</span></div>
    </div>
    <div id="warning">CRITICAL OVERLOAD</div>
    <button id="startButton">START  TEST</button>

    <script>
        // Конфигурация экстремальной нагрузки
        const MAX_PARTICLES = 5000000; // 5 миллионов частиц
        const MEMORY_BLOCKS = 1000; // Количество блоков памяти
        const PHYSICS_STEPS = 100; // Шагов физики за кадр
        const WORKER_COUNT = 16; // Количество веб-воркеров
        const TEXTURE_SIZE = 8192; // Размер текстур 8K
        
        // Глобальные переменные
        let gl;
        let particles = [];
        let memoryBlocks = [];
        let workers = [];
        let cpuUsage = 0;
        let gpuUsage = 0;
        let ramUsage = 0;
        let temperature = 30;
        let frameCount = 0;
        let lastTime = 0;
        let testStarted = false;
        
        // Инициализация теста
        document.getElementById('startButton').addEventListener('click', function() {
            if (testStarted) return;
            
            testStarted = true;
            this.style.display = 'none';
            
            // Инициализация WebGL
            initWebGL();
            
            // Создание частиц
            createParticles();
            
            // Запуск воркеров
            startWorkers();
            
            // Заполнение памяти
            allocateMemory();
            
            // Запуск физики
            setInterval(updatePhysics, 0);
            
            // Запуск основного цикла
            requestAnimationFrame(update);
            
            // Запуск мониторинга
            setInterval(updateStats, 500);
        });
        
        // Инициализация WebGL с интенсивной нагрузкой на GPU
        function initWebGL() {
            const canvas = document.getElementById('glCanvas');
            canvas.width = window.innerWidth * 2;
            canvas.height = window.innerHeight * 2;
            
            gl = canvas.getContext('webgl2', {
                antialias: false,
                powerPreference: "high-performance"
            });
            
            if (!gl) {
                alert('WebGL 2 не поддерживается!');
                return;
            }
            
            // Создание шейдеров
            const vertexShader = `#version 300 es
                precision highp float;
                in vec2 position;
                uniform float time;
                uniform vec2 resolution;
                
                void main() {
                    vec2 p = position;
                    float t = time * 2.0;
                    p.x += sin(t + position.y * 10.0) * 0.2;
                    p.y += cos(t + position.x * 8.0) * 0.2;
                    gl_Position = vec4(p, 0.0, 1.0);
                    gl_PointSize = 3.0;
                }
            `;
            
            const fragmentShader = `#version 300 es
                precision highp float;
                out vec4 fragColor;
                uniform float time;
                
                void main() {
                    vec2 uv = gl_PointCoord * 2.0 - 1.0;
                    float d = length(uv);
                    if (d > 1.0) discard;
                    
                    vec3 color = vec3(
                        0.5 + 0.5 * sin(time * 0.5 + uv.x * 20.0),
                        0.5 + 0.5 * cos(time * 0.7 + uv.y * 18.0),
                        0.5 + 0.5 * sin(time * 1.2)
                    );
                    
                    fragColor = vec4(color * (1.0 - d), 1.0);
                }
            `;
            
            // Компиляция шейдеров
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vertexShader);
            gl.compileShader(vs);
            
            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fragmentShader);
            gl.compileShader(fs);
            
            // Создание программы
            const program = gl.createProgram();
            gl.attachShader(program, vs);
            gl.attachShader(program, fs);
            gl.linkProgram(program);
            gl.useProgram(program);
            
            // Создание буфера частиц
            const positions = new Float32Array(MAX_PARTICLES * 2);
            for (let i = 0; i < MAX_PARTICLES; i++) {
                positions[i * 2] = Math.random() * 2 - 1;
                positions[i * 2 + 1] = Math.random() * 2 - 1;
            }
            
            const buffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
            
            const positionLoc = gl.getAttribLocation(program, 'position');
            gl.enableVertexAttribArray(positionLoc);
            gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);
            
            // Юниформы
            const timeLoc = gl.getUniformLocation(program, 'time');
            const resLoc = gl.getUniformLocation(program, 'resolution');
            gl.uniform2f(resLoc, canvas.width, canvas.height);
            
            // Создание больших текстур для нагрузки на видеопамять
            for (let i = 0; i < 10; i++) {
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                
                const data = new Uint8Array(TEXTURE_SIZE * TEXTURE_SIZE * 4);
                for (let j = 0; j < data.length; j++) {
                    data[j] = Math.random() * 256;
                }
                
                gl.texImage2D(
                    gl.TEXTURE_2D, 0, gl.RGBA, 
                    TEXTURE_SIZE, TEXTURE_SIZE, 0, 
                    gl.RGBA, gl.UNSIGNED_BYTE, data
                );
                
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            }
            
            // Функция рендеринга
            function render(time) {
                gl.uniform1f(timeLoc, time * 0.001);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.drawArrays(gl.POINTS, 0, MAX_PARTICLES);
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        
        // Создание частиц для нагрузки на CPU
        function createParticles() {
            particles = [];
            for (let i = 0; i < MAX_PARTICLES; i++) {
                particles.push({
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    size: Math.random() * 10 + 2,
                    color: `hsl(${Math.random() * 360}, 100%, 50%)`
                });
            }
        }
        
        // Запуск веб-воркеров для нагрузки на ядра CPU
        function startWorkers() {
            const workerCode = `
                self.onmessage = function() {
                    // Интенсивные вычисления
                    while(true) {
                        const start = Date.now();
                        let sum = 0;
                        for (let i = 0; i < 10000000; i++) {
                            sum += Math.sqrt(Math.sin(i) * Math.cos(i));
                        }
                        
                        // Создание больших массивов
                        const bigArray = new Array(1000000);
                        for (let i = 0; i < 1000000; i++) {
                            bigArray[i] = Math.random();
                        }
                        
                        // Сортировка для нагрузки
                        bigArray.sort((a, b) => a - b);
                        
                        // Отправка результата для предотвращения оптимизации
                        postMessage(sum);
                    }
                };
            `;
            
            const blob = new Blob([workerCode], {type: 'application/javascript'});
            const workerURL = URL.createObjectURL(blob);
            
            for (let i = 0; i < WORKER_COUNT; i++) {
                const worker = new Worker(workerURL);
                worker.postMessage('start');
                workers.push(worker);
            }
        }
        
        // Заполнение оперативной памяти
        function allocateMemory() {
            // Создание больших массивов
            for (let i = 0; i < MEMORY_BLOCKS; i++) {
                // Каждый блок ~10MB
                const block = new Float64Array(1310720); // 10.48576 MB
                
                // Заполнение данных для предотвращения оптимизации
                for (let j = 0; j < block.length; j++) {
                    block[j] = Math.random();
                }
                
                memoryBlocks.push(block);
                
                // Визуализация блоков памяти
                const memBlock = document.createElement('div');
                memBlock.className = 'memory-block';
                memBlock.style.width = `${Math.random() * 100 + 20}px`;
                memBlock.style.height = `${Math.random() * 100 + 20}px`;
                memBlock.style.left = `${Math.random() * 100}vw`;
                memBlock.style.top = `${Math.random() * 100}vh`;
                memBlock.style.backgroundColor = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 0.3})`;
                document.body.appendChild(memBlock);
            }
        }
        
        // Интенсивное обновление физики
        function updatePhysics() {
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            // Многократное обновление для увеличения нагрузки
            for (let step = 0; step < PHYSICS_STEPS; step++) {
                for (let i = 0; i < particles.length; i++) {
                    const p = particles[i];
                    
                    // Сложные физические расчеты
                    p.vx += (Math.random() - 0.5) * 0.2;
                    p.vy += (Math.random() - 0.5) * 0.2 + 0.1; // Гравитация
                    
                    p.x += p.vx;
                    p.y += p.vy;
                    
                    // Отскоки от границ
                    if (p.x < 0 || p.x > width) p.vx *= -0.9;
                    if (p.y < 0 || p.y > height) p.vy *= -0.9;
                    
                    // Ограничение координат
                    p.x = Math.max(0, Math.min(width, p.x));
                    p.y = Math.max(0, Math.min(height, p.y));
                    
                    // Дополнительные вычисления
                    const dist = Math.sqrt(p.x * p.x + p.y * p.y);
                    p.vx += 0.01 * Math.sin(dist * 0.01);
                    p.vy += 0.01 * Math.cos(dist * 0.01);
                }
            }
        }
        
        // Основной цикл обновления
        function update(time) {
            frameCount++;
            
            // Расчет FPS
            const deltaTime = time - lastTime;
            lastTime = time;
            const fps = deltaTime > 0 ? 1000 / deltaTime : 0;
            
            // Обновление нагрузки GPU
            gpuUsage = Math.min(100, 10 + (frameCount % 100) + Math.random() * 30);
            
            // Показ предупреждения при высокой нагрузке
            if (cpuUsage > 90 || gpuUsage > 90) {
                document.getElementById('warning').style.opacity = '1';
            } else {
                document.getElementById('warning').style.opacity = '0';
            }
            
            requestAnimationFrame(update);
        }
        
        // Обновление статистики
        function updateStats() {
            // Расчет использования CPU (условный)
            cpuUsage = Math.min(100, cpuUsage + 2 + Math.random() * 5);
            
            // Расчет использования RAM
            ramUsage = Math.floor(performance.memory.usedJSHeapSize / (1024 * 1024));
            
            // Расчет температуры (условный)
            temperature = 30 + Math.min(70, cpuUsage * 0.7);
            
            // Обновление панели
            document.getElementById('cpuLoad').textContent = `${Math.round(cpuUsage)}%`;
            document.getElementById('gpuLoad').textContent = `${Math.round(gpuUsage)}%`;
            document.getElementById('ramUsage').textContent = `${ramUsage} MB`;
            document.getElementById('temp').textContent = `${Math.round(temperature)}°C`;
            
            // Увеличение нагрузки со временем
            if (testStarted) {
                cpuUsage += 1;
                gpuUsage += 0.5;
            }
        }
        
        // Блокировка защитных функций
        window.addEventListener('keydown', (e) => {
            if (e.key === 'F12' || (e.ctrlKey && e.shiftKey && e.key === 'I')) {
                e.preventDefault();
                // Увеличение нагрузки при попытке открыть DevTools
                cpuUsage += 10;
                gpuUsage += 10;
            }
        });
        
        window.onbeforeunload = (e) => {
            e.preventDefault();
            e.returnValue = '';
            return "Системный тест в процессе! Прерывание может вызвать нестабильность системы.";
        };
    </script>
</body>
</html>
